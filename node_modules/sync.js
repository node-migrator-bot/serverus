'use strict';
var _ = require('underscore'),
    Git = require('git'),
    execProcess = require('child_process').exec,
    fs = require('fs'),
    path = require('path'),
    rimraf = require('rimraf');

module.exports = function(options){
    var exporting,
        serverusGitDir = options.dir,
        serverusLockFile = path.join(serverusGitDir, '__serverus.lock'),
        git = new Git({dir: serverusGitDir}),
        branches = {};

    if(!path.existsSync(serverusGitDir)){
        throw new Error(serverusGitDir + ' could not be found - have you inited correctly?');
    }

    if(path.existsSync(serverusLockFile)){
        if(options.force){
            console.log('deleting __serverus.lock file');
            fs.unlinkSync(serverusLockFile);
        }else{
            throw new Error(serverusGitDir + ' locked. Delete __serverus.lock or use --force if you think this is wrong');
        }
    }

    process.on('exit', function(){
        if(path.existsSync(serverusLockFile)){
            fs.unlinkSync(serverusLockFile);
        }
    });

    function getInfoFileName(branchName){
        return path.resolve(options.dir, '../' + branchName.replace('origin/', '').replace(/\//g, '_') + '.json');
    }

    function getCheckoutInfo(branchName){
        var fileName = getInfoFileName(branchName);

        if(path.existsSync(fileName)){
            return JSON.parse(fs.readFileSync(fileName));
        }
        return {};
    }
    function setCheckoutInfo(branchName, info){
        var fileName = getInfoFileName(branchName);

        fs.writeFileSync(fileName, JSON.stringify(info));
    }

    function checkoutTempCopy(ref, callback){
        if(path.existsSync(serverusLockFile)){
            setTimeout(function(){
                checkoutTempCopy(ref, callback);
            }, 2000);
            return;
        }

        fs.writeFileSync(serverusLockFile, new Date() + ' ' + ref);

        git.fetch(function(err){
            if(err) return callback(err);
            console.log('checking out', ref);
            git.checkout(ref + ' --force', function(err){
                if(err) return callback(err);
                git.submodule('update --init --recursive', function(err){
                    if(err) return callback(err);
                    callback(undefined);
                });
            });
        });
    }

    function rsync(fromPath, toPath, callback){
        fromPath = fromPath[fromPath.length - 1] === '/' ? fromPath : fromPath + '/';
        toPath = toPath[toPath.length - 1] === '/' ? toPath : toPath + '/';

        execProcess('rsync --exclude=.git -r --delete "' + fromPath + '" "' + toPath + '"', function(err, output, stdErr){
            if(err) return callback(err);
            callback();
        });
    }

    function checkout(branch, location, callback){
        var info = getCheckoutInfo(branch);

        if(!path.existsSync(location)){
            fs.mkdirSync(location, '0766');
        }

        git.log('-n1 --pretty=oneline "' + branch + '" --', function(err, output){
            if(err) return callback(err);

            var commitRef = output.split(' ')[0];
            if(info.lastCommit === commitRef){
                console.log(branch, 'already up to date');
                callback(err, commitRef);
                return;
            }

            info.lastCommit = commitRef;
            setCheckoutInfo(branch, info);

            console.log('Updating', branch);
            checkoutTempCopy(commitRef, function(err){
                if(err) return callback(err);

                console.log('deploying', branch, '(' + commitRef + ')');
                rsync(serverusGitDir, location, function(err){
                    if(err) return callback(err);

                    branches[branch] = {
                        commitRef: commitRef,
                        location: location
                    };

                    console.log(branch, 'deployed');

                    fs.unlinkSync(serverusLockFile, function(err){
                        if(err){
                            return console.error('Error cleaning up', serverusLockFile, err);
                        }
                        callback(err, commitRef);
                    });
                });
            });
        });
    }

    return _.extend({
        checkout: checkout
    });
};